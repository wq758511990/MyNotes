## 数据存储

原始类型， 即

- number
- string
- boolean
- undefined
- null
- symbol
- bigint
  是存储在栈中，
  所有的对象数据类型存放在堆中。
  需要注意的是闭包变量是存储在内存中，所以会有所谓的内存泄漏问题。

## 垃圾回收

#### 新生代内存的回收

新生代内存空间大小， 64 位、32 位分别为 32M、16M，因其存活时间短

- 将新生代内存一分为二， 一部分为 from， 一部分为 to
- v8 检查 from，若对象存活则移到 to 中，否则回收，当 from 清空时，两者角色对调
- 究其原因，对象移到 to 时时按顺序从头放置的， 故而会将 from 中零散的对象整理成连续的对象， 清除内存碎片

#### 老生代内存的回收

新生代的变量如果经过多次回收之后依然存在，则会被放到老生代内存中，这种现象名为**晋升**

- 已经经历过一次 Scavenge 回收
- To 空间的内存占用超过 25%

满足以上条件则会进入老生代内存。
<br>

- 标记清除
  - 标记阶段， 遍历堆中所有的对象，对其做标记，然后对代码环境中使用的变量以及被引用的变量取消标记，
  - 清除阶段， 取消标记后，依然含有标记的变量，就是无法使用的变量，将其清楚
- 整理内存碎片，变量清除完之后，会进行内存碎片的整理

<br>

- 增量标记
  - 由于 js 单线程，当进行垃圾回收的时候 js 的逻辑无法执行，为了避免严重阻塞的情况发生，v8 才用增量标记，即将一口气完成的标记任务分为很多小的部分完成，完成一小部分就让 js 逻辑执行一会儿，如此循环直到完成垃圾回收过程

## 执行 js 代码过程

- 首先通过词法分析和语法分析生成 AST
- 将 AST 转换为字节码
- 由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率

## eventLoop

- 一开始整段脚本作为第一个宏任务来执行
- 执行过程中，同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
- 当宏任务执行完出队，检查微任务队列，如果有，则一次执行知道清空微任务队列
- 尝试进行 DOM 渲染，执行浏览器 UI 线程的渲染工作
- 检查是否有 web worker 任务，有则执行
- 执行新的宏任务，之后从第二步开始继续循环。

#### eventLoop - nodejs

- timer 阶段
- I/O 异常回调阶段
- 空闲、预备状态(第 2 阶段结束，poll 未触发之前)
- poll 阶段
- check 阶段
- 关闭事件的回调阶段

两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段之间执行的。
