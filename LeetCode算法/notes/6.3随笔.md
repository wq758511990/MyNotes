## 6.2

### 1、（每日一题）837. 新21点

爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

。。。 看题目就给我看晕了。本来以为是个数学题，结果看了一下标签动态规划，又蒙了。

。。。。。。。。。。。。。
恕我太菜了做不出来 感兴趣的可以看一下这道题
[https://leetcode-cn.com/problems/new-21-game/solution/xin-21dian-by-leetcode-solution/]()


### 2、面试题46. 把数字翻译成字符串
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法

这道题比较明显的动态规划的题目。
这类题目的解题方法， 我认为比较好的是先列举几个结果出来，比如输入数字为12258， 列举1， 12， 122， 1225 ，12258， 观察对应的结果，找出规律来，

会发现，如果当前的数字和上一位数字组成的数字无法转换成字母，则当前总的翻译方法和上一段数字的翻译方法一致，即dp[i] = dp[i - 1]，而可以转换为字母的时候，
dp[i] = d[i - 2] + dp[i - 1]
可以写出如下代码
```
class Solution:
    def translateNum(self, num: int) -> int:   
        # 数字转换为字符串
        strNum = str(num)
        # 获取字符串长度
        size = len(strNum)
        # 状态数组
        dp = [0] * (size + 1)
        # 初始化dp[0], dp[1]为1，
        dp[0], dp[1] = 1, 1
        for i in range(2, size + 1):
            # 遍历剩余的字符串，获取当前字符和前一个字符组成的新字符，判断是否有效
            # 有效的话，则dp[i] 为 dp[i - 2] + dp[i - 1]，否则dp[i] = dp[i - 1]
            tmpstr = strNum[i - 2: i]
            dp[i] = dp[i - 2] + dp[i - 1] if int(tmpstr) <= 25 and tmpstr[0] != '0' else dp[i - 1] # 这里要注意新的字符串不能以0开头，否则无效
            
        return dp[-1]
```